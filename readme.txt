
问题一:假如我要用redis来按天统计我的UV,怎么做?
UV统计算法,通常指的是在互联网分析中用于衡量独立访客数量的方法。UV是“Unique Visitor”的缩写，指的是在特定时间段内（通常是一天）通过互联网访问某个网站的不同自然人。
在同一天内，即使同一个用户多次访问网站，也只会被计算一次
1.通过set集合做,set的成员是用户的id,获取成员的总数即可
缺点:内存占用高

2.hyperloglog(2.8.9版本引入的)
特点:
占用内存小;
不知道里边具体元素只能做统计;
存在误差;

什么是hyperloglog？
其实就是基数技术，那什么是基数呢？就是指一个集合中不同元素的个数。
redis hyperloglog 就是基数统计的算法。
可以想到的应用场景：
例如统计一个网页或者网站的访问量（同一个人的多次访问，还算一次访问）。
传统的方式，可以用Set集合来保存用户的id，但是如果用户量太大，就比较占用内存了。
hyperloglog的优点：占用的内存是固定的，2^64个不同元素的基数，只需要占用12kb内存。
但是会有0.81%的错误率，可以忽略不计


问题2:一致性问题
一致性问题的产生:
线程1:查询数据A,查询缓存,发现缓存中 没有数据,查询dB,结果为X1,然后把数据X1写入到缓存中(写入步骤)
线程2:更新数据A,更新DB数据 A=X2,然后删除缓存
假设目前线程2执行完之后,线程1的写入步骤开始执行,那么就造成了缓存不一致问题,即,并发的时候,操作不是原子性的
一致性问题解决方案
最优方案:给redis的缓存加上过期时间,来保证最终的一致性(因为实际的业务操作不全是并发竞争同一个资源,也需要具体看业务是否可以接受短暂的数据不一致情况)
(锁,延时双删 都是为了应付面试,是有损性能的,redis本来就是AP模型,如果为了保证强一致性,而额外做一些有损性能的操作,那就干脆不要用redis了)


问题3:分布式ID,全公司级别的订单ID要如何去生成?
雪花算法,美团leaf 百度 uid-generator
通过redis.increment自增实现(性能不如雪花,而且需要借助redis)

问题4:实际项目中针对100万并发同时访问某个接口时,key失效了,代码如何控制,(缓存击穿问题)
缓存击穿：对于设置了过期时间的 key，缓存在某个时间点过期的时候，恰好这时间点对
这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并
回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。
解决办法:通过双检索控制并发查询DB

问题5:redis异常数据丢失的场景有哪些？
1.RDB,每隔一段时间,触发持久化,会丢失数据
2.默认1s一次,会丢失一秒的数据
3.主从切换,主宕机之前,从的数据没有完全同步过来


数据预热方案:redisTemplate.executePipelined


看门狗机制:通过时间轮+递归实现  位置在:[Seckill-Demo]中